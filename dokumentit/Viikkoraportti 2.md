#Viikkoraportti 2

Aloitin työni luonnostelemalla Dijkstran algoritmia. Algoritmin toteutushan voi olla hyvin erilainen riippuen siitä, miten verkko on esitetty. Päätin toteuttaa itse algoritmin mahdollisimman pseudokoodia vastaavasti. Tietorakenteet ja algoritmit -kurssin materiaalissa esitetty Dijkstran algoritmi saa syötteenä verkon ja aloitussolmun. Olen määritellyt, että syötteenä annetaan kenttä ascii-merkkeinä. Ascii-merkit merkitsevät erilaisia maastoja, joista saadaan verkkoon kaaripainot.

Jotta tekemäni Dijkstran algoritmi saisi syötteenä verkon eikä char-taulukkoa, toteutin Verkko-luokan. Verkko-luokka saa konstruktorissa parametrina kaksiulotteisen char-taulukon ja rakentaa tästä verkon, joka voidaan käsitellä Dijkstran algoritmilla. Verkko-luokka käy läpi kentän jokaisen ruudun vierusruudut, ja lisää kaaria vastaaviin solmuihin tarpeen mukaan. Tässä vaiheessa tuli ongelmia vastaan. Miten tulkitsen erilaiset ascii-merkit kokonaisluvuiksi? Käytössähän ei ole esimerkiksi hajautustaulua, ja jonkinlainen if-rakenne ei tunnu oikealta vaihtoehdolta. Toisaalta, jonkinlainen if-rakenne olisi vakioaikainen operaatio toisin kuin hajautustaulusta hakeminen pahimmillaan. Kumpi kannattaa toteuttaa? Alan kallistua if-rakennetta kohtaan, koska hajautustaulun käyttö vaatisi sen toteuttamisen ja testaamisen. Tarvekin hajautustaululle on pieni. Millainen on tarve lisätä erilaisia maastoja?

Toteutin Minimikeko-rajapinnan, jonka toteuttava olio annetaan algoritmille minimikeoksi. En ollut aikaisemmin toteuttanut geneerisen tyyppisiä tietorakenteita, joten toteutus aiheutti minulle ensin hankaluuksia.

Solmuista lähtee 2-4 kaarta. Tämä tuotti hankaluuksia, sillä taulukkoon voi tallettaa vain tiettyyn kohtaan, ei lisätä alkioita peräkkäin. Toteutin tähän Lista-luokan. Lista-olioon voi lisätä alkioita ja se tallettaa ne taulukkoon järjestyksessä. Ongelmia aiheutti tätä taulukkoa iteroidessa, sillä myös null-olioiden metodeja yritetään kutsua. Tämä vaati algoritmiin erityisen tarkistuksen null-olioiden varalta.

Aloin toteuttamaan Dijkstran algoritmia. Toteutin sen omana luokkanaan, joka saa konstruktorin parametrina Minimikeko-rajapinnan toteuttavan olion. Toteutin myös JavaPriorityQueue -luokan, joka ainoastaan käärii sisäänsä PriorityQueue - luokan toiminnallisuuden ja toteuttaa Minimikeko-rajapinnan. Javan PriorityQueue ei tue heap-decrease operaatiota, joten se pitää toteuttaa poistamalla ensin alkio ja lisäämällä se uudestaan. Tämä vaatii algoritmiin erityisen tarkistuksen siltä varalta, ettei jo käsiteltyä solmu lisätä uudelleen kekoon. Tarkistusta ei voinut lisätä keon toteutukseen,  sillä se on geneerisesti tyypitetty. Algoritmi ei aluksi toiminut. Loppujen lopuksi ongelma oli vain kirjoitusvirheessä, eikä algoritmissa ole vakavampia vikoja.

Testasin algoritmia satunnaisilla kentillä. Loin main-luokkaan metodin, joka luo char-taulukon ja täyttää siihen esteitä. Ensin kenttä tulostetaan. Sitten siitä luodaan verkko ja tälle verkolle suoritetaan Dijkstran algoritmi. Kenttään piirretään syntynyt polku, ja kenttä tulostetaan uudestaan. Algoritmi toimii odotetusti.

Aloitin luokkien Javadoc-kommentoinnin. Jäi epäselväksi täytyykö ihan kaikki kommentoida. Esimerkiksi yksityisiä metodeja tai muuttujia ei ole ennen tarvinnut harjoitustöissä kommentoida, eikä get- tai set-metodeja. Toistaiseksi jätin yksityiset oliomuuttujat kommentoimatta.

Aloitin A*-algoritmin toteutuksen. Haluan käyttää kekoa solmujen valitsemiseen. A*-algoritmissa solmut valitaan kuitenkin kahden etäisyyden mukaan, toisin kuin Dijkstran algoritmissa. Päätin muokata Solmu-luokkaani myös A*-algoritmille sopivaksi. Toinen vaihtoehto olisi ollut Solmu-luokan periminen, mutta en kokenut sitä tarpeelliseksi yhden oliomuuttujan lisäämiseksi. Tietenkin compareTo-metodia täytyi muuttaa. Testasin algoritmin toimintaa samalla tavalla kuin testasin Dijkstran algoritmia, ja se toimii odotetusti. Toteutin myös Bellman-Fordin algoritmin, joka toimi suoraan toteuttamilleni verkoille.

Toteutin Bittikartta-luokan, joka lukee ja luo bmp-tiedostoja. Bittikartta-luokka muuttaa tietyillä väreillä luodut kuvat char-taulukoiksi, joista voidaan luoda verkkoja algoritmeille. Bittikartta-luokan avulla on mahdollista luoda ratkaisut, jos char-taulukoihin ensin kirjoitetaan polku @-merkeillä. Tällöin saadaan kuva, johon ratkaisu on piirretty punaisella.

Päätin poistaa kaiken geneerisen tyypityksen sillä se ei ole olennaista työn kannalta. Lisäksi minulla oli liikaa vaikeuksia niiden kanssa. Kaikki tietorakenteet pitävät nyt sisällään joko solmuja tai kaaria.

Tällä hetkellä mietin mitä toteutan lisää työhöni. Määrittelydokumentissa olen suunnitellut testaavani erilaisia kekoja verkkoalgoritmien kanssa. Olisiko parempaa toteuttaa enemmän algoritmeja vai kekoja? Kuinka monta erilaista? Harkitsen jump point search algoritmin toteuttamista, mutta minulla on vaikeuksia saada siitä selvää. Useat verkonhakualgoritmit ovat vain muokkauksia jostain toisesta algoritmista, onko niiden toetuttaminen kiinnostavaa?


